/*
Metal API

This is the API for Equinix Metal. The API allows you to programmatically interact with all of your Equinix Metal resources, including devices, networks, addresses, organizations, projects, and your user account.  The official API docs are hosted at <https://metal.equinix.com/developers/api>. 

API version: 1.0.0
Contact: support@equinixmetal.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Linger please
var (
	_ context.Context
)

// MarketApiService MarketApi service
type MarketApiService service

type ApiFindMetroSpotMarketPricesRequest struct {
	ctx context.Context
	ApiService *MarketApiService
	metro *string
	plan *string
}

// Metro to filter spot market prices
func (r ApiFindMetroSpotMarketPricesRequest) Metro(metro string) ApiFindMetroSpotMarketPricesRequest {
	r.metro = &metro
	return r
}
// Plan to filter spot market prices
func (r ApiFindMetroSpotMarketPricesRequest) Plan(plan string) ApiFindMetroSpotMarketPricesRequest {
	r.plan = &plan
	return r
}

func (r ApiFindMetroSpotMarketPricesRequest) Execute() (*SpotMarketPricesPerMetroList, *http.Response, error) {
	return r.ApiService.FindMetroSpotMarketPricesExecute(r)
}

/*
FindMetroSpotMarketPrices Get current spot market prices for metros

Get Equinix Metal current spot market prices for all metros.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindMetroSpotMarketPricesRequest
*/
func (a *MarketApiService) FindMetroSpotMarketPrices(ctx context.Context) ApiFindMetroSpotMarketPricesRequest {
	return ApiFindMetroSpotMarketPricesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotMarketPricesPerMetroList
func (a *MarketApiService) FindMetroSpotMarketPricesExecute(r ApiFindMetroSpotMarketPricesRequest) (*SpotMarketPricesPerMetroList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotMarketPricesPerMetroList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.FindMetroSpotMarketPrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/market/spot/prices/metros"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metro != nil {
		localVarQueryParams.Add("metro", parameterToString(*r.metro, ""))
	}
	if r.plan != nil {
		localVarQueryParams.Add("plan", parameterToString(*r.plan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindSpotMarketPricesRequest struct {
	ctx context.Context
	ApiService *MarketApiService
	facility *string
	plan *string
}

// Facility to check spot market prices
func (r ApiFindSpotMarketPricesRequest) Facility(facility string) ApiFindSpotMarketPricesRequest {
	r.facility = &facility
	return r
}
// Plan to check spot market prices
func (r ApiFindSpotMarketPricesRequest) Plan(plan string) ApiFindSpotMarketPricesRequest {
	r.plan = &plan
	return r
}

func (r ApiFindSpotMarketPricesRequest) Execute() (*SpotMarketPricesList, *http.Response, error) {
	return r.ApiService.FindSpotMarketPricesExecute(r)
}

/*
FindSpotMarketPrices Get current spot market prices

Get Equinix Metal current spot market prices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindSpotMarketPricesRequest
*/
func (a *MarketApiService) FindSpotMarketPrices(ctx context.Context) ApiFindSpotMarketPricesRequest {
	return ApiFindSpotMarketPricesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotMarketPricesList
func (a *MarketApiService) FindSpotMarketPricesExecute(r ApiFindSpotMarketPricesRequest) (*SpotMarketPricesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotMarketPricesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.FindSpotMarketPrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/market/spot/prices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.facility != nil {
		localVarQueryParams.Add("facility", parameterToString(*r.facility, ""))
	}
	if r.plan != nil {
		localVarQueryParams.Add("plan", parameterToString(*r.plan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindSpotMarketPricesHistoryRequest struct {
	ctx context.Context
	ApiService *MarketApiService
	facility *string
	plan *string
	from *string
	until *string
	metro *string
}

// Facility to check spot market prices
func (r ApiFindSpotMarketPricesHistoryRequest) Facility(facility string) ApiFindSpotMarketPricesHistoryRequest {
	r.facility = &facility
	return r
}
// Plan to check spot market prices
func (r ApiFindSpotMarketPricesHistoryRequest) Plan(plan string) ApiFindSpotMarketPricesHistoryRequest {
	r.plan = &plan
	return r
}
// Timestamp from range
func (r ApiFindSpotMarketPricesHistoryRequest) From(from string) ApiFindSpotMarketPricesHistoryRequest {
	r.from = &from
	return r
}
// Timestamp to range
func (r ApiFindSpotMarketPricesHistoryRequest) Until(until string) ApiFindSpotMarketPricesHistoryRequest {
	r.until = &until
	return r
}
// Metro to check spot market price history
func (r ApiFindSpotMarketPricesHistoryRequest) Metro(metro string) ApiFindSpotMarketPricesHistoryRequest {
	r.metro = &metro
	return r
}

func (r ApiFindSpotMarketPricesHistoryRequest) Execute() (*SpotPricesHistoryReport, *http.Response, error) {
	return r.ApiService.FindSpotMarketPricesHistoryExecute(r)
}

/*
FindSpotMarketPricesHistory Get spot market prices for a given period of time

Get spot market prices for a given plan and facility in a fixed period of time

*Note: In the `200` response, the property `datapoints` contains arrays of `[float, integer]`.*

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindSpotMarketPricesHistoryRequest
*/
func (a *MarketApiService) FindSpotMarketPricesHistory(ctx context.Context) ApiFindSpotMarketPricesHistoryRequest {
	return ApiFindSpotMarketPricesHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotPricesHistoryReport
func (a *MarketApiService) FindSpotMarketPricesHistoryExecute(r ApiFindSpotMarketPricesHistoryRequest) (*SpotPricesHistoryReport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotPricesHistoryReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.FindSpotMarketPricesHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/market/spot/prices/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.facility == nil {
		return localVarReturnValue, nil, reportError("facility is required and must be specified")
	}
	if r.plan == nil {
		return localVarReturnValue, nil, reportError("plan is required and must be specified")
	}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.until == nil {
		return localVarReturnValue, nil, reportError("until is required and must be specified")
	}

	localVarQueryParams.Add("facility", parameterToString(*r.facility, ""))
	localVarQueryParams.Add("plan", parameterToString(*r.plan, ""))
	if r.metro != nil {
		localVarQueryParams.Add("metro", parameterToString(*r.metro, ""))
	}
	localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	localVarQueryParams.Add("until", parameterToString(*r.until, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
